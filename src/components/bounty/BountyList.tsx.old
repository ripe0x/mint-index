import React, { useState, useEffect } from "react";
import { useAccount } from "wagmi";
import { Address } from "viem";
import { fetchBountyFactoryEvents } from "@/lib/fetchBountyEvents";
import { abiMintBounty } from "@/abi/abiMintBounty";
import { DEFAULT_TOKEN_CONTRACT } from "@/lib/bountyHelpers";
import { BountyCard } from "./BountyCard";
import { client } from "@/config";

interface BountyInfo {
  bountyContract: Address;
  owner: Address;
  tokenContracts: Address[];
}

type FilterType = "all" | "claimable" | "owned";

export const BountyList: React.FC = () => {
  const { address } = useAccount();
  const [bounties, setBounties] = useState<BountyInfo[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter] = useState<FilterType>("all");
  const [refreshKey, setRefreshKey] = useState(0);

  // Fetch all bounty contracts and their token contracts
  useEffect(() => {
    async function loadBounties() {
      setLoading(true);
      try {
        // Get all deployed bounty contracts from factory events
        const deployedContracts = await fetchBountyFactoryEvents();

        // For each contract, fetch the actual owner if not provided
        const bountyInfosPromises = deployedContracts.map(
          async (deployment) => {
            let owner = deployment.owner;

            // If owner is zero address, fetch from contract
            if (owner === "0x0000000000000000000000000000000000000000") {
              try {
                const ownerResult = await client.readContract({
                  address: deployment.bountyContract,
                  abi: abiMintBounty,
                  functionName: "owner",
                });
                owner = ownerResult as Address;
              } catch (err) {
                console.error(
                  "Error fetching owner for",
                  deployment.bountyContract,
                  err
                );
              }
            }

            return {
              bountyContract: deployment.bountyContract,
              owner,
              tokenContracts: [DEFAULT_TOKEN_CONTRACT], // Default to the main token contract
            };
          }
        );

        const bountyInfos = await Promise.all(bountyInfosPromises);
        setBounties(bountyInfos);
      } catch (error) {
        console.error("Error loading bounties:", error);
      } finally {
        setLoading(false);
      }
    }

    loadBounties();
  }, [refreshKey]);

  const handleRefresh = () => {
    setRefreshKey((prev) => prev + 1);
  };

  const isOwned = (bounty: BountyInfo) => {
    return address && bounty.owner.toLowerCase() === address.toLowerCase();
  };

  // Filter bounties based on selected filter
  const filteredBounties = bounties.filter((bounty) => {
    if (filter === "owned") {
      return isOwned(bounty);
    }
    // For "claimable" filter, we'd need to check isBountyClaimable for each
    // For now, showing all for "all" and "claimable"
    return true;
  });

  // Sort bounties (simplified for now - would need to read contract data for full sorting)
  const sortedBounties = [...filteredBounties];

  if (loading) {
    return (
      <div className="space-y-4">
        <div className="animate-pulse">
          <div className="h-32 bg-gray-200 rounded-lg mb-4"></div>
          <div className="h-32 bg-gray-200 rounded-lg mb-4"></div>
          <div className="h-32 bg-gray-200 rounded-lg"></div>
        </div>
      </div>
    );
  }

  return (
    <div>
      {/* Filters and Controls */}
      {/* <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
        <div className="flex flex-wrap gap-2">
          <select
            value={filter}
            onChange={(e) => setFilter(e.target.value as FilterType)}
            className="px-3 py-2 border border-gray-300 rounded text-sm"
          >
            <option value="all">Show All</option>
            <option value="claimable">Show Claimable</option>
            <option value="owned">Show Owned</option>
          </select>

          <select
            value={sort}
            onChange={(e) => setSort(e.target.value as SortType)}
            className="px-3 py-2 border border-gray-300 rounded text-sm"
          >
            <option value="recent">Most Recent</option>
            <option value="balance">Highest Balance</option>
            <option value="rewards">Most Rewards</option>
          </select>
        </div>

        <button
          onClick={handleRefresh}
          className="px-4 py-2 border border-gray-300 rounded text-sm hover:bg-gray-50 transition-colors"
        >
          ðŸ”„ Refresh
        </button>
      </div> */}

      {/* Bounty List */}
      {sortedBounties.length === 0 ? (
        <div className="text-center py-8 text-gray-500">
          {filter === "owned"
            ? "You don't own any bounty contracts yet."
            : "No bounties found."}
        </div>
      ) : (
        <div className="space-y-6">
          {sortedBounties.map((bounty) => (
            <div key={bounty.bountyContract}>
              {/* Show bounty cards for each token contract */}
              {bounty.tokenContracts.map((tokenContract) => (
                <div
                  key={`${bounty.bountyContract}-${tokenContract}`}
                  className="mb-4"
                >
                  <BountyCard
                    bountyContract={bounty.bountyContract}
                    isOwner={isOwned(bounty)}
                    onUpdate={handleRefresh}
                  />

                  {/* Management controls removed temporarily - needs update for new ABI */}
                </div>
              ))}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
